
int Minimax::mini(State* prev_state, int depth, Move move)
{
  State* state = prev_state->next_state(move);
  state->get_legal_actions();
  std::vector<Move> action = state->legal_actions;
  std::vector<Move>::iterator it;
  auto minicompare = [](int lhs, int rhs) {return lhs < rhs;};
  std::priority_queue<int, std::vector<int>, decltype(minicompare)> possible_state_value;
  for(it = action.begin();it != action.end(); it++)
  {
    possible_state_value.push(max(state, depth - 1, *it));
  }
  return possible_state_value.top();
}

int Minimax::max(State* prev_state, int depth, Move move)
{
  State* state = prev_state->next_state(move);
  state->get_legal_actions();
  std::vector<Move> action = state->legal_actions;
  std::vector<Move>::iterator it;
  auto maxcompare = [](int lhs, int rhs) {return lhs > rhs;};
  std::priority_queue<int, std::vector<int>, decltype(maxcompare)> possible_state_value;
  for(it = action.begin();it != action.end(); it++)
  {
    if(depth == 0) possible_state_value.push(state->next_state(*it)->evaluate());
    else possible_state_value.push(mini(state, depth - 1, *it));
  }
  return possible_state_value.top();
}